# Module 2: "TF Vocabulary" Feature Engineering

## 1. Objective

The objective of this module is to implement the core feature engineering process. This involves creating input sequences for the Siamese transformer model by generating a feature vector for each base in the promoter regions. Each per-base feature vector will be a concatenation of a one-hot encoded DNA sequence vector and a vector of TF-DAPseq binding affinity values for that base. While this module is titled "TF Vocabulary" Feature Engineering, its direct output is these rich per-base feature sequences, from which the downstream model will learn the "TF vocabulary".

## 2. Key Responsibilities

-   Ingest the promoter DNA sequences and normalized per-base TF binding signals generated by Module 1.
-   Develop a robust pipeline to generate a feature vector for each base in the promoter regions.
-   Implement one-hot encoding for DNA sequences:
    -   A -> [1,0,0,0]
    -   C -> [0,1,0,0]
    -   G -> [0,0,1,0]
    -   T -> [0,0,0,1]
    -   N (any ambiguity) -> [1,1,1,1] (or another defined scheme like [0.25,0.25,0.25,0.25])
    -   Pad token -> [0,0,0,0] (if padding/truncation to a fixed length is applied).
-   For each base, concatenate its one-hot encoded DNA vector with its corresponding TF-DAPseq vector (the ~300 TF binding affinity values for that specific base from Module 1).
-   Generate the final feature set where each promoter is represented as a sequence of these concatenated per-base feature vectors.

## 3. Detailed Implementation Steps

### Step 3.1: Load Input Data from Module 1

-   **Inputs:**
    1.  **Promoter DNA Sequences:** The file (e.g., FASTA or TSV) from Module 1 (Output of Step 3.1 in `module_1_data_preprocessing.md`) containing the `gene_id` and its corresponding `promoter_dna_sequence`.
    2.  **Normalized Per-Base TF Binding Signals:** The directory of `.npy` files from Module 1 (Output of Step 3.3 in `module_1_data_preprocessing.md`). Each file, named by `gene_id`, contains a NumPy matrix of shape `(Number_of_TFs x Promoter_Length)` with normalized TF binding affinity values. Assume `Number_of_TFs` is approximately 300.
-   **Process:**
    -   Write a loader to read the promoter DNA sequences for all relevant genes.
    -   Write a loader to read the corresponding normalized per-base TF binding signal `.npy` files. Ensure alignment between a gene's DNA sequence and its TF binding data.

### Step 3.2: Prepare DNA Sequence Vectors (One-Hot Encoding & Padding)

-   **Rationale:** Convert the symbolic DNA sequence into a numerical format suitable for the model and ensure all sequences have a consistent length if required by the model architecture.
-   **Process:**
    1.  **Define Maximum Sequence Length (If applicable):** Determine if a fixed sequence length is required for the transformer model in Module 3. If so, choose a `MAX_PROMOTER_LENGTH`. This could be based on the distribution of promoter lengths (e.g., 95th percentile) or a predefined value.
    2.  **One-Hot Encode:** For each DNA base in a promoter sequence:
        -   Convert A to [1,0,0,0]
        -   Convert C to [0,1,0,0]
        -   Convert G to [0,0,1,0]
        -   Convert T to [0,0,0,1]
        -   Convert N to [1,1,1,1] (as specified in `implementation_plan_overview.md`)
        This results in a sequence of 4-dimensional vectors for each promoter.
    3.  **Padding/Truncation (If fixed length is applied):**
        -   If a `MAX_PROMOTER_LENGTH` is set:
            -   **Pad:** If a promoter sequence is shorter than `MAX_PROMOTER_LENGTH`, append pad vectors ([0,0,0,0]) to the end of its one-hot encoded sequence until it reaches `MAX_PROMOTER_LENGTH`.
            -   **Truncate:** If a promoter sequence is longer, truncate it (e.g., by taking the central part, or from the Transcription Start Site outwards, depending on biological relevance and strategy).
-   **Output:** For each gene, a 2D NumPy array of shape `(Actual_Promoter_Length or MAX_PROMOTER_LENGTH, 4)` containing the one-hot encoded (and possibly padded/truncated) DNA sequence.

### Step 3.3: Concatenate DNA and TF Affinity Features Per Base

-   **Rationale:** Combine the sequence information and the TF binding information at each base position to create a rich, multimodal feature vector.
-   **Process:**
    1.  Iterate through each base position of a processed promoter sequence (up to `Actual_Promoter_Length` or `MAX_PROMOTER_LENGTH`).
    2.  At each base `i`:
        -   Take the one-hot encoded DNA vector for that base (from Step 3.2). This is a 4-dimensional vector.
        -   Take the TF binding affinity vector for that base. This is a slice from the normalized TF binding signal matrix from Module 1, corresponding to the `i`-th base. This vector will have `Number_of_TFs` (e.g., ~300) dimensions. (Ensure TF matrix is `Promoter_Length x Number_of_TFs` or transpose if necessary from Module 1's `Number_of_TFs x Promoter_Length`). If padding was applied to the DNA sequence, use a corresponding vector of zeros (or a specific padding representation) for the TF affinities in padded positions.
        -   Concatenate these two vectors. The resulting feature vector for base `i` will have `(4 + Number_of_TFs)` dimensions.
-   **Output:** For each gene, a 2D NumPy array (matrix) of shape `(Actual_Promoter_Length or MAX_PROMOTER_LENGTH, 4 + Number_of_TFs)`.

### Step 3.4: Generate Final Promoter Representation

-   **Process:** The matrix generated in Step 3.3 for each gene is its final feature-engineered representation.
-   **Store Data:** Save this final matrix for each gene.
    -   **Recommendation:** Use NumPy's `.npy` format, one file per gene, named by `gene_id`.
-   **Output:** A directory of `.npy` files. Each file contains a matrix of shape `(Actual_Promoter_Length or MAX_PROMOTER_LENGTH, 4 + Number_of_TFs)`, representing the promoter as a sequence of concatenated per-base feature vectors. This data is the direct input for the Siamese transformer model (Module 3).

## 4. Recommended Libraries

-   **`NumPy`**: For all numerical and matrix/vector operations, and for saving/loading `.npy` files.
-   **`pandas`**: Potentially for loading initial gene lists or DNA sequences if in TSV format.
-   **`Biopython`**: If DNA sequences are loaded from FASTA files.
-   **`scikit-learn`**: `OneHotEncoder` could be an option for DNA encoding, though manual implementation is straightforward.
-   **`multiprocessing` / `joblib`**: This task is highly parallelizable (processing can be done per gene). Utilizing these libraries can significantly speed up feature generation for a large number of genes.

## 5. Deliverables and Success Criteria

This module is complete when, for all relevant genes:

1.  Input DNA sequences and normalized per-base TF binding signals from Module 1 have been successfully ingested.
2.  DNA sequences have been one-hot encoded (and potentially padded/truncated to a consistent length).
3.  For each base, the one-hot DNA vector has been concatenated with the corresponding TF binding affinity vector.
4.  The resulting sequence of concatenated feature vectors for each promoter is saved as a `.npy` file.

The primary deliverable is **a dataset (directory of `.npy` files) where each gene's promoter is represented as a 2D matrix (sequence of concatenated per-base feature vectors), ready for Module 3.** The code should be well-documented, efficient, and capable of processing all genes.
